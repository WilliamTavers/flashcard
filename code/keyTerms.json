[{"front": "Race Condition", "back": "When two computer program processes, or threads, attempt to access the same resource at the same time and cause problems in the system"}, {"front": "Condition variable", "back": "A tool that makes threads wait until a specific condition is true"}, {"front": "Semaphore", "back": "A synchronisation primitive that maintains an integer counter to control how many threads can access shared resources at the same time"}, {"front": "Mutual Exclusion", "back": "A concurrency control property that ensures only one thread can access a shared resources (critical section) at any given time"}, {"front": "Deadlock", "back": "A state where two or more threads are blocked indefinitely, each waiting for the other to release the resources they need"}, {"front": "Hold-and-Wait", "back": "A  thread holding resources is waiting to acquire more held by other threads, potentially leading to deadlock"}, {"front": "Preemption", "back": "The operating system forces a process to stop and lets another proces run. Can help resolve deadlocks"}, {"front": "Non-Preemption", "back": "Any new process has to wait until the running process finishes its CPU cycle (cannot interrupt)"}, {"front": "Circular Wait", "back": "A circular chain of threads, each holding a resource that is being requested by the next thread in the chain"}, {"front": "Banker's Algorithm", "back": "A resource allocation and deadlock avoidance algorithm that evaluates resource requests to ensure the system remains in a safe state, where deadlock is impossible"}, {"front": "Livelock", "back": "Where two or more processes continuously change their state in response to each other, but without making any actual progress"}, {"front": "Operating System (OS)", "back": "Software that manages hardware resources and provides services for computer programs."}, {"front": "Process", "back": "A program in execution, including the program code and its current activity.\nProcesses change their state as they execute and can be either new, ready, running, waiting or terminated."}, {"front": "Multiprogramming", "back": "Running multiple processes simultaneously by switching between them"}, {"front": "Context Switch", "back": "The process of saving the state of one process and loading the state of another"}, {"front": "CPU Scheduling", "back": "The method by which an operating system decides which process runs at any given time"}, {"front": "Memory Address Space", "back": "The rand of memory addresses that a process can use"}, {"front": "Logical Address", "back": "The address generated by the CPU"}, {"front": "Physical Address", "back": "The actual location in the phyiscal memory hardware"}, {"front": "Address Translation", "back": "Converting logical addresses into physical addresses using a memory management unit (MMU)"}, {"front": "Segmentation", "back": "Divides a program's memory inot segments such as code, data, and stack. Each segment has a base and a limit"}, {"front": "Paging", "back": "Divides memory into fixed-size pages. Physical memory is divided into frames, and each frame holds one page of data."}, {"front": "Page Table", "back": "A table that stores the mapping between a process's logical pages and the physical frames"}, {"front": "Fragmentation", "back": "Wasted space in memory. It can be internal (within allocated space) or external (between allocated spaces)."}, {"front": "Translation Lookaside Buffer (TLB)", "back": "A cache that stores recent translations of logical to physical addresses for faster access"}, {"front": "Swapping", "back": "Moving processes between main memory and disk storage to free up space for other processes"}, {"front": "Multi-level paging", "back": "A paging scheme where page tables are divided into multiple levels to save memory"}, {"front": "Inverted Page Table", "back": "A single page table that contains entries for all pages in memory, indexed by the frame number"}, {"front": "Concurrency", "back": "When multiple tasks are making progress at the same time"}, {"front": "Thread", "back": "A lightweight process that shares resources like memory with other threads within the same process"}, {"front": "Parallelism", "back": "The simultaneous execution of multiple threads or processes"}, {"front": "User-level threads", "back": "Threads managed by user-level libraries rather than the operating system kernel"}, {"front": "Lock", "back": "A synchronisation mechanism used to enforce mutual exclusion when accessing shared resources"}, {"front": "Mutex (Mutual Exclusion)", "back": "A type of lock that ensures only one thread can access a resource at a time"}, {"front": "Spinlock", "back": "A lock where a thread continously checks if it can acquire the lock, wasting CPU time"}, {"front": "Condition Variable", "back": "A synchronisation primitive that allows threads to wait for a condition before continuing"}, {"front": "Semaphore", "back": "A synchronisation primitive that uses counters to manage access to shared resources"}, {"front": "Binary Semaphore", "back": "A semaphore with only two values (0 and 1), used to implement mutual exclusion"}, {"front": "Starvation", "back": "When a process is perpetually denied access to necessary resources"}, {"front": "I/O Device", "back": "Hardware used to communicate between a computer system and the outside world (e.g., keyboard, disk)"}, {"front": "Device Driver", "back": "Software that controls an I/O device and provides an interface to the operating system"}, {"front": "Hard Disk Drive (HDD)", "back": "A storage device that uses spinning disks to store data magnetically"}, {"front": "Seek Time", "back": "The time it takes for a disk drive's read/write head to move to the correct track on the disk"}, {"front": "RAID (Redundant Array of Independent Disks)", "back": "A method of combining multiple disk drives for performance improvement or redundancy"}, {"front": "File", "back": "A collection of data sotred on a storage device"}, {"front": "Directory", "back": "A system used to organise and manage files on a storage device"}, {"front": "File System", "back": "The method and data structures used by the operating system to manage files and directories"}, {"front": "File System Implementation", "back": "The process of defining how files are stored, accessed, and managed on disk"}, {"front": "FFS (Fast File System)", "back": "A file system that improves performance by organising data into large blocks and using techniques like cylinder groups to reduce fragmentation"}, {"front": "Inode", "back": "A data structure used by many file systems to represent a file's metadata, like permissions and file size"}, {"front": "Superblock", "back": "A metadata structure that contains information about a file system, including its size and status"}, {"front": "FSCK (File System Consistency Check)", "back": "A utility that checks and repairs inconsistencies in a file system"}, {"front": "Journaling", "back": "A technique that ensures file system consistency by logging changes before they are applied"}, {"front": "LFS (Log-Structured File System)", "back": "A file system where all modifications are written sequentially in a log, optimising write performance and crash recovery"}, {"front": "Checkpointing", "back": "Saving the state of a file system at regular intervals to enable recovery in case of failure"}]