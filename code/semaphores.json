[{"front": "What are race conditions and why are they difficult to debug?", "back": "Race conditions occur when multiple threads access and try to modify shared data simultaneously, leading to unpredictable outcomes. They're difficult to debug because they often occur under specific timing conditions, making them hard to reproduce consistently."}, {"front": "Explain the core functionalities of condition variables in thread synchronization.", "back": "Condition variables facilitate thread synchronisation through two main functions: wait() which atomically releases a held lock and puts the calling thread to sleep until signaled, and signal() which wakes up one of the threads wating on the condition variable."}, {"front": "List and briefly define the four conditions that must be met for deadlock to occur.", "back": "1) Mutual Exclusion: only one thread can access a resource at  a time. \n2) Hold-and-Wait: A process must be holding at least one resource while simultaneously waiting to acquire additional resources. \n3) No Preemption: Resources cannot be foricbly taken away from a process. \n4) Circular Wait: A circular chain of processes exist, each waiting for the next."}, {"front": "Describe the two primary operations associated with semaphores and their effects", "back": "The two primary semaphore operations are wait() and post(). Wait() decrements the semaphore value if it's greater than zero, otherwise, the calling thread is blocked. Post() increments the sempahore value nad potentially wakes up a waiting thread"}]